<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@300;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #1a1a1a;
            --accent-color: #000000;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #000000;
                --text-color: #e5e5e5;
                --accent-color: #ffffff;
            }
        }

        body.js-loading { opacity: 0; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Noto Serif TC', serif;
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: opacity 0.8s ease;
        }
        
        * { cursor: none !important; }
        @media (hover: none) or (max-width: 768px) {
            * { cursor: auto !important; }
        }

        #custom-cursor {
            position: fixed; top: 0; left: 0; width: 12px; height: 12px;
            background-color: var(--accent-color);
            transform: rotate(45deg);
            pointer-events: none;
            z-index: 99999;
            transition: transform 0.1s, width 0.2s, height 0.2s, background-color 0.2s, border 0.2s;
        }
        #custom-cursor.hollow {
            background: transparent;
            border: 1.5px solid var(--accent-color);
            transform: rotate(45deg) scale(1.2);
        }
        #custom-cursor.clicking {
            transform: rotate(45deg) scale(0.8);
            background: var(--accent-color);
        }

        .back-arrow {
            position: fixed; top: 30px; left: 30px; opacity: 0.5; z-index: 100; transition: 0.3s;
            border: none; background: none; padding: 0;
        }
        .back-arrow:hover { opacity: 1; }
        .back-arrow svg { width: 24px; height: 24px; fill: var(--text-color); }

        .reader-viewport {
            flex: 1;
            width: 100%; /* 手機版全寬 */
            max-width: 800px; /* 桌面版最大寬度 */
            margin: 80px auto;
            position: relative;
            overflow: hidden; /* 關鍵：讓頁面滑動時內容不溢出 */
            touch-action: pan-y; /* 允許垂直滾動，但主要用於控制滑動 */
        }

        .page-slide {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 0 40px; /* 預設內邊距 */
            opacity: 0; pointer-events: none;
            transform: translateX(30px);
            transition: opacity 0.4s ease, transform 0.4s ease; /* 狀態切換時的過渡 */
            display: flex; flex-direction: column;
            justify-content: center; /* 內容垂直居中 */
            gap: 25px;
            box-sizing: border-box; /* 確保 padding 不影響 width/height */
        }
        .page-slide.active { opacity: 1; pointer-events: auto; transform: translateX(0); }

        /* --- 手機版滑動時，暫停 CSS transition --- */
        .page-slide.is-swiping {
            transition: none;
        }

        p {
            font-size: clamp(1.1rem, 2.2vmin, 1.35rem);
            line-height: 1.9;
            text-align: justify;
            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-origin: left center;
        }
        
        p:hover { transform: scale(1.02); }
        p:active { transform: scale(0.98); }

        .title-slide { text-align: center; }
        .title-slide h1 { font-size: 2.2rem; font-weight: 500; margin-bottom: 20px; }
        .title-slide .meta { font-size: 0.9rem; opacity: 0.6; font-family: sans-serif; }

        .pagination {
            position: fixed; bottom: 30px; width: 100%;
            display: flex; justify-content: center; align-items: center; gap: 40px;
            font-family: sans-serif; font-size: 0.9rem; user-select: none;
            z-index: 10; /* 確保導航在滑動時總是在頂層 */
        }
        
        .nav-btn {
            opacity: 0.3; padding: 10px; transition: 0.3s;
            border: none; background: none; color: inherit; font-family: inherit; font-size: inherit;
        }
        .nav-btn:hover, .nav-btn:focus { opacity: 1; outline: none; }
        .nav-btn:disabled { opacity: 0.1; }

        .page-indicator { opacity: 0.5; font-size: 0.8rem; letter-spacing: 2px; }

        @media (max-width: 768px) {
            #custom-cursor { display: none; }
            .reader-viewport { margin: 60px auto 100px; }
            .page-slide { padding: 0 25px; gap: 20px; } /* 手機版內邊距 */
            .pagination { bottom: 20px; }
        }
    </style>
</head>
<body class="js-loading">
    <div id="custom-cursor"></div>

    <button class="back-arrow interactable" onclick="goBack()" aria-label="返回文章列表">
        <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
    </button>

    <main class="reader-viewport" id="viewport" aria-live="polite" aria-atomic="true"></main>

    <nav class="pagination" role="navigation" aria-label="文章分頁">
        <button class="nav-btn interactable" id="prev-btn" aria-controls="viewport">PREV</button>
        <div class="page-indicator" id="page-num" aria-live="polite">1 / 1</div>
        <button class="nav-btn interactable" id="next-btn" aria-controls="viewport">NEXT</button>
    </nav>

    <script>
        const articleContent = {
            title: "幾何美學的構建",
            date: "2023.11.02",
            paragraphs: [
                "這是第一段內容。在數字的荒原裡，我們試圖用線條和角度構建一座燈塔。點擊任意文本段落即可複製，動畫效果已經調整為非常微小的縮放，保持閱讀的沈浸感。",
                "這是第二段。為了適應不同屏幕，這段 JS 腳本會測量瀏覽器的高度。如果屏幕很高，這一頁可能會顯示三到四個段落；如果是在手機上，可能只能顯示兩段。",
                "設計不應該喧賓奪主，而應該退居幕後。白色背景，黑色文字，沒有多餘的裝飾。每一個像素的間距都是為了呼吸而留。",
                "這是第四段測試長文本。當網絡不好的時候，Moment 頁面的圖片會顯示加載動畫，而在文章頁面，所有的文字都是即時渲染的。",
                "這是新的一頁的內容嗎？取決於你的屏幕大小。我們會逝去，但文字會留下來。翻頁閱讀讓思緒有了停頓的間隙，不再是無止盡的滑動。",
                "最後一段。保持熱愛，奔赴山海。純粹的文字記錄，有時候比圖像更有力量。"
            ]
        };

        const viewport = document.getElementById('viewport');
        const pageNum = document.getElementById('page-num');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const cursor = document.getElementById('custom-cursor');

        let currentPage = 0;
        let totalPages = 0;
        let pages = [];
        let touchStartX = 0;
        let touchMoveX = 0;
        let isSwiping = false; // 新增：標記是否正在滑動
        const SWIPE_BUFFER = 100; // 左右滑動的緩衝區 px

        function layoutArticle() {
            viewport.innerHTML = '';
            pages = [];
            currentPage = 0;
            const viewportHeight = viewport.clientHeight;
            if (viewportHeight <= 0) return;

            const titlePage = createPageDiv(0, true);
            titlePage.innerHTML = `<h1>${articleContent.title}</h1><div class="meta">${articleContent.date}</div>`;
            pages.push(titlePage);

            let contentPageIndex = 1;
            let currentPageDiv = createPageDiv(contentPageIndex);
            pages.push(currentPageDiv);
            
            const pageStyle = getComputedStyle(currentPageDiv);
            const paragraphGap = parseFloat(pageStyle.gap) || 25;
            const fragment = document.createDocumentFragment();
            const tempDiv = document.createElement('div');
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.position = 'absolute';
            // 確保 tempDiv 的寬度考慮了 viewport 的 padding
            tempDiv.style.width = `${viewport.clientWidth - (parseFloat(pageStyle.paddingLeft) + parseFloat(pageStyle.paddingRight))}px`;
            fragment.appendChild(tempDiv);
            
            let currentHeight = 0;

            articleContent.paragraphs.forEach(text => {
                const p = document.createElement('p');
                p.className = 'interactable-text';
                p.innerText = text;
                p.onclick = () => copyText(p);
                tempDiv.innerHTML = '';
                tempDiv.appendChild(p.cloneNode(true));
                const pHeight = tempDiv.clientHeight;

                if (currentHeight > 0 && currentHeight + pHeight + paragraphGap > viewportHeight) {
                    contentPageIndex++;
                    currentPageDiv = createPageDiv(contentPageIndex);
                    pages.push(currentPageDiv);
                    currentHeight = 0;
                }
                currentPageDiv.appendChild(p);
                currentHeight += pHeight + paragraphGap;
            });
            
            pages.forEach(page => viewport.appendChild(page));
            totalPages = pages.length;
            updatePage();
            bindCursorEvents();
        }

        function createPageDiv(index, isTitle = false) {
            const div = document.createElement('div');
            div.className = 'page-slide';
            if (isTitle) div.classList.add('title-slide');
            div.dataset.index = index;
            return div;
        }

        function changePage(dir) {
            const newPage = currentPage + dir;
            if (newPage >= 0 && newPage < totalPages) {
                currentPage = newPage;
                updatePage();
            }
        }

        function updatePage() {
            pages.forEach((page, index) => {
                page.style.transition = 'transform 0.4s ease, opacity 0.4s ease'; // 恢復過渡
                page.style.transform = ''; // 清除手動拖曳的 transform
                page.classList.toggle('active', index === currentPage);
            });
            pageNum.innerText = `${currentPage + 1} / ${totalPages}`;
            prevBtn.disabled = (currentPage === 0);
            nextBtn.disabled = (currentPage === totalPages - 1);
        }

        async function copyText(el) {
            try { await navigator.clipboard.writeText(el.innerText); } 
            catch (err) { console.error('Failed to copy text: ', err); }
        }

        function goBack() {
            document.body.style.opacity = '0';
            setTimeout(() => { alert("返回上一頁"); }, 500);
        }

        function initNavigation() {
            prevBtn.addEventListener('click', () => changePage(-1));
            nextBtn.addEventListener('click', () => changePage(1));
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') { e.preventDefault(); prevBtn.click(); } 
                else if (e.key === 'ArrowRight') { e.preventDefault(); nextBtn.click(); }
            });
        }
        
        function initSwipeNavigation() {
            // 僅在觸摸設備或小螢幕上啟用
            if (!window.matchMedia("(hover: none) or (max-width: 768px)").matches) return;

            viewport.addEventListener('touchstart', handleTouchStart, { passive: true });
            viewport.addEventListener('touchmove', handleTouchMove, { passive: true });
            viewport.addEventListener('touchend', handleTouchEnd, { passive: true });
            // 阻止一些默認觸摸行為，例如頁面滾動，除非是在特定元素上
            document.addEventListener('touchmove', (e) => {
                if (isSwiping) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        function handleTouchStart(e) {
            // 僅處理單點觸摸
            if (e.touches.length !== 1) return;
            
            touchStartX = e.touches[0].clientX;
            touchMoveX = touchStartX;
            isSwiping = false; // 重置滑動狀態
            pages.forEach(page => page.classList.add('is-swiping')); // 移除 CSS transition
        }

        function handleTouchMove(e) {
            if (e.touches.length !== 1) return;
            
            const currentX = e.touches[0].clientX;
            const deltaX = currentX - touchStartX;
            touchMoveX = currentX; // 記錄最後一次移動的位置
            
            const activePage = pages[currentPage];
            if (!activePage) return;

            // --- 核心修改點 1: 精確限制滑動範圍 ---
            let constrainedDeltaX = deltaX;
            
            // 如果是第一頁，向右滑動受限
            if (currentPage === 0 && deltaX > 0) {
                constrainedDeltaX = Math.min(deltaX, SWIPE_BUFFER);
            } 
            // 如果是最後一頁，向左滑動受限
            else if (currentPage === totalPages - 1 && deltaX < 0) {
                constrainedDeltaX = Math.max(deltaX, -SWIPE_BUFFER);
            }
            // 中間頁面不受邊界限制，但整體移動不能超出 viewport 範圍
            else {
                 constrainedDeltaX = Math.max(-SWIPE_BUFFER, Math.min(SWIPE_BUFFER, deltaX));
            }

            activePage.style.transform = `translateX(${constrainedDeltaX}px)`;
            isSwiping = true; // 開始滑動
        }

        function handleTouchEnd() {
            const activePage = pages[currentPage];
            if (!activePage) return;

            const deltaX = touchMoveX - touchStartX;
            const swipeThreshold = 50; // 滑動超過 50px 才算翻頁

            if (deltaX < -swipeThreshold && currentPage < totalPages - 1) {
                changePage(1); // 向左滑，下一頁
            } else if (deltaX > swipeThreshold && currentPage > 0) {
                changePage(-1); // 向右滑，上一頁
            } else {
                // 滑動距離不足或超出邊界，彈回原位
                updatePage();
            }
            
            // 滑動結束後，重新啟用 CSS transition
            pages.forEach(page => page.classList.remove('is-swiping'));
            isSwiping = false; // 滑動結束
        }

        function initCursor() {
            if (window.matchMedia("(hover: none) or (max-width: 768px)").matches) return;
            
            document.addEventListener('mousemove', e => {
                cursor.style.left = `${e.clientX}px`;
                cursor.style.top = `${e.clientY}px`;
            });
            document.addEventListener('mousedown', () => cursor.classList.add('clicking'));
            document.addEventListener('mouseup', () => cursor.classList.remove('clicking'));
            
            bindCursorEvents();
        }

        function bindCursorEvents() {
             if (window.matchMedia("(hover: none) or (max-width: 768px)").matches) return;

            document.querySelectorAll('.interactable, .interactable-text').forEach(el => {
                el.addEventListener('mouseenter', () => cursor.classList.add('hollow'));
                el.addEventListener('mouseleave', () => cursor.classList.remove('hollow'));
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            layoutArticle();

            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(layoutArticle, 250);
            });

            initNavigation();
            initSwipeNavigation(); // 啟用滑動導航
            initCursor();
            
            document.body.classList.remove('js-loading');
        });
    </script>
</body>
</html>
