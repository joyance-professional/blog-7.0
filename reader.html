<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Article Reader</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg-color: #ffffff; --text-color: #1a1a1a; --accent-color: #000000; --placeholder-bg: #f0f0f0; --menu-bg: rgba(255,255,255,0.95); }
        @media (prefers-color-scheme: dark) { :root { --bg-color: #000000; --text-color: #e5e5e5; --accent-color: #ffffff; --placeholder-bg: #1c1c1e; --menu-bg: rgba(0,0,0,0.9); } }
        
        body.js-loading { opacity: 0; visibility: hidden; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Noto Serif TC', serif; margin: 0; height: 100vh; width: 100vw; overflow: hidden; display: flex; flex-direction: column; transition: opacity 0.8s ease; user-select: none; -webkit-user-select: none; }
        * { cursor: none !important; box-sizing: border-box; }
        @media (hover: none) or (max-width: 768px) { * { cursor: auto !important; } }
        
        /* Custom Cursor */
        #custom-cursor { position: fixed; top: 0; left: 0; width: 12px; height: 12px; background-color: var(--accent-color); transform: rotate(45deg); pointer-events: none; z-index: 99999; transition: transform 0.1s, width 0.2s, height 0.2s, background-color 0.2s, border 0.2s; will-change: transform, left, top; }
        #custom-cursor.hollow { background: transparent; border: 1.5px solid var(--accent-color); transform: rotate(45deg) scale(1.2); }
        #custom-cursor.clicking { transform: rotate(45deg) scale(0.8); background: var(--accent-color); }

        /* UI Controls */
        .ui-layer { position: fixed; z-index: 100; top: 0; left: 0; width: 100%; height: 0; pointer-events: none; }
        .interactable { pointer-events: auto; cursor: pointer !important; }
        
        .back-arrow { position: fixed; top: 30px; left: 30px; opacity: 0.5; transition: 0.3s; border: none; background: none; padding: 10px; }
        .back-arrow:hover { opacity: 1; }
        .back-arrow svg { width: 24px; height: 24px; fill: var(--text-color); }
        
        .toc-btn { position: fixed; top: 30px; right: 30px; opacity: 0.5; transition: 0.3s; border: none; background: none; padding: 10px; display: flex; flex-direction: column; gap: 4px; align-items: flex-end; }
        .toc-btn:hover { opacity: 1; }
        .toc-line { height: 2px; background: var(--text-color); transition: 0.3s; }
        .toc-line:nth-child(1) { width: 24px; } .toc-line:nth-child(2) { width: 16px; } .toc-line:nth-child(3) { width: 20px; }
        
        /* Reader Viewport */
        .reader-viewport { flex: 1; width: 100%; max-width: 800px; margin: 80px auto; position: relative; touch-action: pan-y; }
        .page-slide { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0 40px; opacity: 0; pointer-events: none; transform: translateX(30px); transition: opacity 0.4s ease, transform 0.4s ease; display: flex; flex-direction: column; justify-content: center; gap: 25px; }
        .page-slide.active { opacity: 1; pointer-events: auto; transform: translateX(0); }
        .page-slide.is-swiping { transition: none; }
        
        /* Typography */
        p { font-size: clamp(1.1rem, 2.2vmin, 1.35rem); line-height: 1.8; text-align: justify; margin: 0; word-break: break-word; overflow-wrap: break-word; }
        h1, h2, h3 { margin: 0; font-weight: 700; line-height: 1.4; }
        h1 { font-size: 2.2rem; text-align: center; margin-bottom: 20px; }
        h2 { font-size: 1.5rem; margin-top: 10px; border-left: 3px solid var(--accent-color); padding-left: 15px; }
        .title-slide .meta { font-size: 0.9rem; opacity: 0.6; font-family: sans-serif; text-align: center; margin-top: 10px; }

        /* Images */
        figure { margin: 0; padding: 0; width: 100%; display: flex; flex-direction: column; align-items: center; }
        figure img { max-width: 100%; max-height: 50vh; width: auto; height: auto; display: block; border-radius: 4px; transition: transform 0.3s; object-fit: contain; }
        .image-wrapper { width: 100%; display: flex; justify-content: center; position: relative; min-height: 100px; }
        .image-wrapper:hover img { transform: scale(1.01); }
        figcaption { font-size: 0.9rem; font-family: sans-serif; text-align: center; opacity: 0.7; margin-top: 10px; width: 100%; }
        
        /* Loading & Error States */
        .loading-placeholder { width: 100%; height: 250px; background-color: var(--placeholder-bg); border-radius: 4px; animation: pulse 1.5s infinite ease-in-out; display: flex; align-items: center; justify-content: center; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        .retry-btn { background: none; border: 1px solid var(--text-color); color: var(--text-color); padding: 8px 16px; font-family: sans-serif; opacity: 0.7; transition: 0.2s; }
        .retry-btn:hover { opacity: 1; background: var(--text-color); color: var(--bg-color); }

        /* Pagination */
        .pagination { position: fixed; bottom: 30px; width: 100%; display: flex; justify-content: center; align-items: center; gap: 40px; font-family: sans-serif; font-size: 0.9rem; z-index: 100; }
        .nav-btn { opacity: 0.3; padding: 10px; transition: 0.3s; border: none; background: none; color: inherit; font-family: inherit; font-size: inherit; }
        .nav-btn:hover, .nav-btn:focus { opacity: 1; outline: none; }
        .nav-btn:disabled { opacity: 0.05; cursor: default !important; }
        .page-indicator { opacity: 0.5; font-size: 0.8rem; letter-spacing: 2px; min-width: 60px; text-align: center; }

        /* Table of Contents Overlay */
        .toc-overlay { position: fixed; top: 0; right: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; opacity: 0; pointer-events: none; transition: 0.3s; }
        .toc-overlay.open { opacity: 1; pointer-events: auto; }
        .toc-panel { position: absolute; top: 0; right: 0; width: 300px; max-width: 80%; height: 100%; background: var(--menu-bg); transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1); padding: 80px 30px; overflow-y: auto; backdrop-filter: blur(10px); display: flex; flex-direction: column; gap: 20px; }
        .toc-overlay.open .toc-panel { transform: translateX(0); }
        .toc-item { font-size: 1.1rem; opacity: 0.6; transition: 0.2s; padding: 10px 0; border-bottom: 1px solid var(--placeholder-bg); }
        .toc-item:hover { opacity: 1; padding-left: 10px; }
        .toc-item.active { opacity: 1; font-weight: 500; border-left: 2px solid var(--accent-color); padding-left: 10px; border-bottom: none; }

        /* Lightbox */
        .lightbox { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: var(--bg-color); z-index: 2000; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .lightbox.active { opacity: 1; pointer-events: auto; }
        .lightbox img { max-width: 95%; max-height: 95%; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }

        /* Exit Hint & Overlay */
        .exit-hint { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.8rem; font-family: sans-serif; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 500; }
        .exit-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color); z-index: 3000; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        .exit-overlay.active { opacity: 1; }
        .exit-text { font-size: 1.5rem; font-weight: 300; letter-spacing: 5px; animation: glow 2s infinite ease-in-out; }
        @keyframes glow { 0%, 100% { opacity: 0.5; text-shadow: 0 0 5px var(--accent-color); } 50% { opacity: 1; text-shadow: 0 0 20px var(--accent-color); } }

        @media (max-width: 768px) { 
            #custom-cursor { display: none; } 
            .reader-viewport { margin: 60px auto 100px; width: 90%; } 
            .page-slide { padding: 0 10px; gap: 20px; } 
            .pagination { bottom: 20px; } 
            h1 { font-size: 1.8rem; }
            p { text-align: left; } /* Mobile readability */
        }
    </style>
</head>
<body class="js-loading">
    <div id="custom-cursor"></div>
    
    <!-- UI Layer -->
    <div class="ui-layer">
        <button class="back-arrow interactable" onclick="attemptGoBack(true)" aria-label="返回文章列表">
            <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        </button>
        <button class="toc-btn interactable" id="toc-btn" aria-label="目錄">
            <div class="toc-line"></div><div class="toc-line"></div><div class="toc-line"></div>
        </button>
    </div>

    <!-- Main Content -->
    <main class="reader-viewport" id="viewport" aria-live="polite">
        <div class="loading-placeholder"></div>
    </main>

    <!-- Navigation -->
    <nav class="pagination">
        <button class="nav-btn interactable" id="prev-btn">PREV</button>
        <div class="page-indicator" id="page-num">...</div>
        <button class="nav-btn interactable" id="next-btn">NEXT</button>
    </nav>

    <!-- Overlays -->
    <div class="toc-overlay" id="toc-overlay">
        <div class="toc-panel" id="toc-list">
            <!-- TOC Items generated here -->
        </div>
    </div>

    <div class="lightbox" id="lightbox">
        <img src="" alt="Zoomed Image">
    </div>

    <div class="exit-hint" id="exit-hint">再次滑動以返回列表</div>
    
    <div class="exit-overlay" id="exit-overlay">
        <div class="exit-text">RETURNING...</div>
    </div>

<script>
    // --- Configuration & State ---
    const CONFIG = {
        paragraphGap: 25,
        maxImageHeightRatio: 0.55, // Image can take up to 55% of viewport height
        swipeThreshold: 60,
        renderChunkSize: 3 // Render 3 elements at a time to prevent UI freeze
    };

    const els = {
        viewport: document.getElementById('viewport'),
        pageNum: document.getElementById('page-num'),
        prevBtn: document.getElementById('prev-btn'),
        nextBtn: document.getElementById('next-btn'),
        cursor: document.getElementById('custom-cursor'),
        tocOverlay: document.getElementById('toc-overlay'),
        tocList: document.getElementById('toc-list'),
        lightbox: document.getElementById('lightbox'),
        lightboxImg: document.querySelector('#lightbox img'),
        exitHint: document.getElementById('exit-hint'),
        exitOverlay: document.getElementById('exit-overlay')
    };

    let state = {
        currentPage: 0,
        totalPages: 0,
        pages: [], // DOM elements
        toc: [], // { text: string, pageIndex: number }
        isSwiping: false,
        touchStartX: 0,
        touchMoveX: 0,
        exitSwipeStage: 0, // 0: none, 1: hint shown, 2: exiting
        exitTimer: null,
        isLayoutComplete: false
    };

    // --- Core Logic: Fetch & Render ---

    async function fetchArticleContent(id) {
        if (!id) throw new Error("Article ID is missing.");
        try {
            // Simulate fetch. Replace with: const response = await fetch(`./article/${id}.json`);
            // For demo, we return the structure directly if fetch fails (or use mock).
            // Here is the requested logic to fetch:
            const response = await fetch(`./article/${id}.json`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
        } catch (error) {
            console.warn("Fetch failed, using mock data for demo if available or throwing error.");
            throw error;
        }
    }

    async function initialize() {
        try {
            const params = new URLSearchParams(window.location.search);
            // Default ID for testing if none provided, or remove logic for production
            const articleId = params.get('id'); 
            
            const content = await fetchArticleContent(articleId);
            await document.fonts.ready;
            
            setupInteraction();
            await startLayoutEngine(content);
            
            window.addEventListener('resize', debounce(() => {
                // Full re-layout on resize is expensive, reload page or smart adjust
                location.reload(); 
            }, 500));
            
        } catch (error) {
            console.error(error);
            els.viewport.innerHTML = `<p style="text-align:center; padding-top:50px;">載入文章失敗。<br><button class="retry-btn interactable" onclick="location.reload()">重試</button></p>`;
        } finally {
            document.body.classList.remove('js-loading');
        }
    }

    // --- Layout Engine (The Complex Part) ---

    async function startLayoutEngine(content) {
        document.title = content.title;
        els.viewport.innerHTML = '';
        state.pages = [];
        state.toc = [];
        state.currentPage = 0;
        
        // 1. Create Title Page
        const titlePage = createPage(0);
        titlePage.innerHTML = `<h1>${content.title}</h1><div class="meta">${content.date}</div>`;
        addPage(titlePage);
        updateNav();

        // 2. Prepare Calculation Environment
        const viewportHeight = els.viewport.clientHeight;
        const pageStyle = getComputedStyle(titlePage);
        const vPadding = parseFloat(pageStyle.paddingTop) + parseFloat(pageStyle.paddingBottom);
        const availableHeight = viewportHeight - vPadding;
        
        // Hidden container for measurement
        const measureBox = document.createElement('div');
        measureBox.style.cssText = `position:absolute; visibility:hidden; width:${els.viewport.clientWidth - (parseFloat(pageStyle.paddingLeft)*2)}px; top:0; left:0; z-index:-1;`;
        document.body.appendChild(measureBox);

        // 3. Process Content Stream
        let currentPageIdx = 1;
        let currentPageDiv = createPage(currentPageIdx);
        let currentHeight = 0;
        let tempElements = []; // Hold elements before committing to a page

        function commitPage() {
            if (tempElements.length > 0) {
                tempElements.forEach(el => currentPageDiv.appendChild(el));
                addPage(currentPageDiv);
                tempElements = [];
            }
            currentPageIdx++;
            currentPageDiv = createPage(currentPageIdx);
            currentHeight = 0;
            updateNav(); // Update UI progressively
        }

        // --- Generator Loop for Async Processing ---
        const items = content.paragraphs;
        
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            let element = null;
            let itemHeight = 0;

            // Small delay every few items to let UI breathe (Main Thread unblocking)
            if (i % CONFIG.renderChunkSize === 0 && i > 0) await new Promise(r => setTimeout(r, 0));

            if (typeof item === 'string') {
                element = document.createElement('p');
                element.className = 'interactable-text';
                element.textContent = item;
                // Add to measure box
                measureBox.appendChild(element);
                itemHeight = element.offsetHeight;
                measureBox.removeChild(element);
                
                // Check fit
                if (currentHeight + itemHeight + CONFIG.paragraphGap > availableHeight) {
                    commitPage(); // Start new page
                }
                
                tempElements.push(element);
                currentHeight += itemHeight + CONFIG.paragraphGap;

            } else if (item.type === 'header') {
                // Header Logic
                element = document.createElement(`h${Math.min(item.level + 1, 3)}`);
                element.textContent = item.text;
                element.id = `section-${i}`;
                
                measureBox.appendChild(element);
                itemHeight = element.offsetHeight;
                measureBox.removeChild(element);

                // If header is at the very bottom, push to next page
                if (currentHeight + itemHeight + CONFIG.paragraphGap + 100 > availableHeight) {
                    commitPage();
                }

                // Add to TOC map (Use current Page Index if empty, else next one if full?)
                // Actually, since we haven't committed yet, it belongs to `currentPageIdx`.
                // Optimization: if it's the very first item on a page, height is 0.
                state.toc.push({ text: item.text, pageIndex: currentPageIdx });
                
                tempElements.push(element);
                currentHeight += itemHeight + CONFIG.paragraphGap;

            } else if (item.type === 'image') {
                // Image Logic - Complex because of loading
                const wrapper = document.createElement('figure');
                wrapper.className = 'image-wrapper interactable';
                
                const placeholder = document.createElement('div');
                placeholder.className = 'loading-placeholder';
                wrapper.appendChild(placeholder);
                
                // We need to estimate height or wait for it. 
                // To keep layout stable, we try to load the image.
                const img = new Image();
                img.alt = item.alt || '';
                
                // Promise wrapper for loading
                let imgHeight = 250; // default
                try {
                    await new Promise((resolve) => {
                        img.onload = () => {
                            // Calculate scaled height fitting in width
                            const ratio = img.naturalHeight / img.naturalWidth;
                            const displayedWidth = measureBox.clientWidth; // Width constraints
                            let calcHeight = displayedWidth * ratio;
                            
                            // Max height constraint
                            const maxH = viewportHeight * CONFIG.maxImageHeightRatio;
                            if (calcHeight > maxH) {
                                calcHeight = maxH;
                                img.style.objectFit = 'contain';
                                img.style.height = `${maxH}px`;
                            }
                            imgHeight = calcHeight;
                            resolve();
                        };
                        img.onerror = () => {
                            resolve(); // Continue layout even if fail
                        };
                        img.src = item.src;
                    });
                    
                    wrapper.replaceChild(img, placeholder);
                    if (item.caption) {
                        const cap = document.createElement('figcaption');
                        cap.textContent = item.caption;
                        wrapper.appendChild(cap);
                        imgHeight += 30; // approx caption height
                    }
                    
                    // Click to zoom
                    wrapper.onclick = (e) => {
                        e.stopPropagation();
                        openLightbox(item.src);
                    };

                } catch (e) {
                    // Error Handling UI
                    wrapper.innerHTML = '';
                    const errBtn = document.createElement('button');
                    errBtn.className = 'retry-btn interactable';
                    errBtn.textContent = '圖片載入失敗 - 點擊重試';
                    errBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Reload current article logic or specific image reload
                        // Simple hack: re-layout is safer for pagination
                        location.reload(); 
                    };
                    wrapper.appendChild(errBtn);
                    wrapper.style.height = '150px';
                    wrapper.style.display = 'flex';
                    wrapper.style.alignItems = 'center';
                    wrapper.style.justifyContent = 'center';
                    imgHeight = 150;
                }

                // Check fit
                if (currentHeight + imgHeight + CONFIG.paragraphGap > availableHeight && currentHeight > 50) {
                    commitPage();
                }
                
                tempElements.push(wrapper);
                currentHeight += imgHeight + CONFIG.paragraphGap;
            }
        }

        commitPage(); // Commit last page
        document.body.removeChild(measureBox);
        state.totalPages = state.pages.length;
        state.isLayoutComplete = true;
        
        generateTOC();
        updateNav();
        bindCursorEvents(); // Re-bind for new elements
    }

    // --- Helper Functions ---

    function createPage(index) {
        const div = document.createElement('div');
        div.className = `page-slide ${index === 0 ? 'active' : ''}`;
        if (index === 0) div.classList.add('title-slide');
        div.dataset.index = index;
        return div;
    }

    function addPage(pageDiv) {
        state.pages.push(pageDiv);
        els.viewport.appendChild(pageDiv);
        state.totalPages = state.pages.length;
    }

    function changePage(delta) {
        const target = state.currentPage + delta;
        if (target >= 0 && target < state.totalPages) {
            goToPage(target);
        }
    }

    function goToPage(index) {
        state.currentPage = index;
        state.pages.forEach((p, i) => {
            p.classList.toggle('active', i === index);
            p.style.transform = ''; // Reset swipe transforms
        });
        updateNav();
        // Reset exit hint state when changing pages
        state.exitSwipeStage = 0; 
        els.exitHint.style.opacity = '0';
    }

    function updateNav() {
        els.pageNum.textContent = state.isLayoutComplete 
            ? `${state.currentPage + 1} / ${state.totalPages}` 
            : `${state.currentPage + 1} / ...`;
        
        els.prevBtn.disabled = state.currentPage === 0;
        els.nextBtn.disabled = state.isLayoutComplete && state.currentPage === state.totalPages - 1;
        
        // Highlight TOC
        document.querySelectorAll('.toc-item').forEach(item => {
            const idx = parseInt(item.dataset.page);
            item.classList.toggle('active', idx === state.currentPage);
        });
    }

    function generateTOC() {
        els.tocList.innerHTML = '';
        if (state.toc.length === 0) {
            els.tocList.innerHTML = '<div style="opacity:0.5; text-align:center;">無目錄</div>';
            return;
        }
        
        // Add Title
        const homeLink = document.createElement('div');
        homeLink.className = 'toc-item interactable';
        homeLink.textContent = "封面";
        homeLink.dataset.page = 0;
        homeLink.onclick = () => { goToPage(0); toggleTOC(); };
        els.tocList.appendChild(homeLink);

        state.toc.forEach(item => {
            const div = document.createElement('div');
            div.className = 'toc-item interactable';
            div.textContent = item.text;
            div.dataset.page = item.pageIndex;
            div.onclick = () => {
                goToPage(item.pageIndex);
                toggleTOC();
            };
            els.tocList.appendChild(div);
        });
    }

    // --- Interaction Logic ---

    function setupInteraction() {
        // Nav Buttons
        els.prevBtn.onclick = () => attemptGoBack(false); // Check swipe logic inside
        els.nextBtn.onclick = () => changePage(1);
        
        // TOC
        document.getElementById('toc-btn').onclick = toggleTOC;
        els.tocOverlay.onclick = (e) => { if(e.target === els.tocOverlay) toggleTOC(); };

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') els.prevBtn.click();
            if (e.key === 'ArrowRight') els.nextBtn.click();
            if (e.key === 'Escape') {
                if (els.lightbox.classList.contains('active')) closeLightbox();
                else if (els.tocOverlay.classList.contains('open')) toggleTOC();
            }
        });

        // Lightbox
        els.lightbox.onclick = closeLightbox;

        // Swipe
        if (window.matchMedia("(hover: none) or (max-width: 768px)").matches) {
            initSwipe();
        } else {
            initCursor();
        }
    }

    function toggleTOC() {
        els.tocOverlay.classList.toggle('open');
    }

    function openLightbox(src) {
        els.lightboxImg.src = src;
        els.lightbox.classList.add('active');
    }

    function closeLightbox() {
        els.lightbox.classList.remove('active');
        setTimeout(() => els.lightboxImg.src = '', 300);
    }

    function attemptGoBack(isUiClick) {
        // Logic for "Going Back"
        // If UI button click -> Direct exit
        if (isUiClick) {
            triggerExitAnim();
            return;
        }
        // If Prev Button click (or Arrow Left) -> Normal page logic
        if (state.currentPage > 0) {
            changePage(-1);
        } else {
            // If on first page and clicks Prev -> Hint
            handleExitIntent();
        }
    }

    // --- Swipe & Cursor Logic ---

    function initSwipe() {
        els.viewport.addEventListener('touchstart', (e) => {
            state.touchStartX = e.touches[0].clientX;
            state.touchMoveX = state.touchStartX;
            state.isSwiping = true;
            if(state.pages[state.currentPage]) state.pages[state.currentPage].classList.add('is-swiping');
        }, { passive: true });

        els.viewport.addEventListener('touchmove', (e) => {
            if (!state.isSwiping) return;
            state.touchMoveX = e.touches[0].clientX;
            const deltaX = state.touchMoveX - state.touchStartX;
            
            // Visual drag effect with resistance at edges
            let constrainedDeltaX = deltaX;
            if ((state.currentPage === 0 && deltaX > 0) || (state.currentPage === state.totalPages - 1 && deltaX < 0)) {
                constrainedDeltaX *= 0.3; // High resistance for exit intent
            }
            if(state.pages[state.currentPage]) state.pages[state.currentPage].style.transform = `translateX(${constrainedDeltaX}px)`;
        }, { passive: true });

        els.viewport.addEventListener('touchend', () => {
            if (!state.isSwiping) return;
            state.isSwiping = false;
            const deltaX = state.touchMoveX - state.touchStartX;
            
            if(state.pages[state.currentPage]) state.pages[state.currentPage].classList.remove('is-swiping');
            
            // Reset transform or Change Page
            if (deltaX < -CONFIG.swipeThreshold) {
                // Swipe Left (Next)
                if (state.currentPage < state.totalPages - 1) changePage(1);
                else {
                    // End of article swipe
                    goToPage(state.currentPage); // Reset position
                    handleExitIntent();
                }
            } else if (deltaX > CONFIG.swipeThreshold) {
                // Swipe Right (Prev)
                if (state.currentPage > 0) changePage(-1);
                else {
                    // Start of article swipe
                    goToPage(state.currentPage); // Reset position
                    handleExitIntent();
                }
            } else {
                goToPage(state.currentPage); // Reset
            }
        }, { passive: true });
    }

    function handleExitIntent() {
        if (state.exitSwipeStage === 0) {
            // First time: Show Hint
            state.exitSwipeStage = 1;
            els.exitHint.style.opacity = '1';
            
            clearTimeout(state.exitTimer);
            state.exitTimer = setTimeout(() => {
                state.exitSwipeStage = 0;
                els.exitHint.style.opacity = '0';
            }, 3000);
        } else if (state.exitSwipeStage === 1) {
            // Second time: Exit
            triggerExitAnim();
        }
    }

    function triggerExitAnim() {
        state.exitSwipeStage = 2;
        els.exitHint.style.opacity = '0';
        els.exitOverlay.classList.add('active');
        setTimeout(() => {
            window.location.href = './articles.html';
        }, 1200);
    }

    function initCursor() {
        document.addEventListener('mousemove', e => {
            els.cursor.style.left = `${e.clientX}px`;
            els.cursor.style.top = `${e.clientY}px`;
        });
        document.addEventListener('mousedown', () => els.cursor.classList.add('clicking'));
        document.addEventListener('mouseup', () => els.cursor.classList.remove('clicking'));
        bindCursorEvents();
    }

    function bindCursorEvents() {
        if (window.matchMedia("(hover: none)").matches) return;
        document.querySelectorAll('.interactable, .interactable-text').forEach(el => {
            el.addEventListener('mouseenter', () => els.cursor.classList.add('hollow'));
            el.addEventListener('mouseleave', () => els.cursor.classList.remove('hollow'));
        });
    }

    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // Start
    window.addEventListener('load', initialize);

</script>
</body>
</html>
