<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Article</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root { 
            --bg-color: #ffffff; 
            --text-color: #1a1a1a; 
            --accent-color: #000000; 
            --placeholder-bg: #f0f0f0; 
            --toc-width: 280px;
            --ease-fluid: cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @media (prefers-color-scheme: dark) { 
            :root { --bg-color: #000000; --text-color: #e5e5e5; --accent-color: #ffffff; --placeholder-bg: #1c1c1e; } 
        }

        body.js-loading { opacity: 0; visibility: hidden; }
        body { 
            background-color: var(--bg-color); 
            color: var(--text-color); 
            font-family: 'Noto Serif TC', serif; 
            margin: 0; 
            height: 100vh; 
            width: 100vw; 
            overflow: hidden; 
            transition: opacity 0.8s ease; 
        }
        
        /* 全局隱藏默認鼠標 */
        * { cursor: none !important; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        @media (hover: none) or (max-width: 768px) { * { cursor: auto !important; } }

        #app-container { display: flex; width: 100%; height: 100%; transition: transform 0.3s ease; }
        .main-content { flex: 1; position: relative; height: 100%; display: flex; flex-direction: column; overflow: hidden; transition: margin-right 0.3s cubic-bezier(0.16, 1, 0.3, 1); }

        /* --- 自定義鼠標 (重做版) --- */
        #custom-cursor { 
            position: fixed; top: 0; left: 0; 
            width: 12px; height: 12px; 
            background-color: var(--accent-color); 
            pointer-events: none; z-index: 999999; 
            /* 初始隱藏，由 JS 控制顯示與位置 */
            opacity: 0;
            mix-blend-mode: difference; 
            display: block;
            will-change: transform, width, height; /* 啟用 GPU 加速 */
            transition: width 0.2s cubic-bezier(0.16, 1, 0.3, 1), 
                        height 0.2s cubic-bezier(0.16, 1, 0.3, 1), 
                        background-color 0.2s;
        }
        /* 鼠標狀態樣式 */
        #custom-cursor.active { opacity: 1; }
        #custom-cursor.hollow { 
            background: transparent; 
            border: 1.5px solid var(--accent-color); 
        }
        /* scale 和 rotate 現在由 JS 統一管理以避免衝突，這裡只定義基本外觀變更 */

        /* 頂部按鈕 */
        .top-controls { position: fixed; top: 30px; left: 30px; z-index: 100; pointer-events: none; }
        .desktop-toc-trigger { position: fixed; top: 30px; right: 30px; z-index: 100; pointer-events: none; }
        
        .icon-btn { opacity: 0.5; transition: 0.3s; border: none; background: none; padding: 10px; display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        .icon-btn:hover { opacity: 1; transform: scale(1.1); }
        .icon-btn svg { width: 24px; height: 24px; fill: var(--text-color); }

        /* --- 閱讀視口 --- */
        .reader-viewport { 
            flex: 1; 
            width: 100%; 
            max-width: 800px; 
            height: calc(100vh - 160px); 
            margin: 80px auto; 
            position: relative; 
            touch-action: pan-y; 
        }
        
        .page-slide { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0 40px; 
            opacity: 0; pointer-events: none; 
            transform: translateX(60px); 
            transition: opacity 0.5s var(--ease-fluid), transform 0.5s var(--ease-fluid); 
            display: flex; flex-direction: column; justify-content: center; gap: 25px; 
            overflow: hidden; 
        }
        
        .page-slide.active { opacity: 1; pointer-events: auto; transform: translateX(0); }
        .page-slide.prev-page { opacity: 0; transform: translateX(-60px); pointer-events: none; }
        .reader-viewport.no-anim .page-slide { transition: none !important; }

        /* 文字樣式 */
        p { 
            font-size: clamp(1.1rem, 2.2vmin, 1.35rem); 
            line-height: 1.9; text-align: justify; margin: 0; font-weight: 400; 
            overflow-wrap: break-word; transform-origin: left center; transition: transform 0.2s;
        }
        p:hover { transform: scale(1.005); }
        
        h1, h2, h3 { margin: 0; font-weight: 600; line-height: 1.4; }
        .article-heading { margin-top: 10px; margin-bottom: 10px; }
        .article-heading[data-level="1"] { font-size: 1.8rem; border-left: 4px solid var(--accent-color); padding-left: 15px; font-weight: 700; }
        .article-heading[data-level="2"] { font-size: 1.4rem; opacity: 0.9; padding-left: 5px; font-weight: 600; }

        /* --- 圖片 (修復版：不壓縮比例) --- */
        figure { 
            margin: 0; padding: 0; 
            width: 100%; 
            /* 移除固定高度限制，讓 JS 決定換頁 */
            height: auto; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
        }
        figure img { 
            /* 改為寬度優先或自動，防止強制拉伸 */
            width: auto;
            height: auto;
            max-width: 100%; 
            /* 限制最大高度不超過視口，但使用 contain 保持比例 */
            max-height: 100%; 
            object-fit: contain;
            border-radius: 4px; 
            opacity: 0; transition: opacity 0.5s ease, transform 0.3s;
        }
        figure img.loaded { opacity: 1; }
        figure img:hover { transform: scale(1.02); }
        
        #lightbox {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; visibility: hidden; transition: 0.3s;
            backdrop-filter: blur(5px);
        }
        #lightbox.active { opacity: 1; visibility: visible; }
        #lightbox img { max-width: 95vw; max-height: 95vh; object-fit: contain; transform: scale(0.9); transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1); box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #lightbox.active img { transform: scale(1); }

        .loading-placeholder { width: 100%; height: 250px; background-color: var(--placeholder-bg); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: var(--text-color); opacity: 0.5; font-size: 0.9rem; }
        .loading-placeholder.pulsing { animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* 底部 UI */
        .pagination { position: fixed; bottom: 30px; width: 100%; display: flex; justify-content: center; align-items: center; gap: 40px; font-family: sans-serif; font-size: 0.9rem; user-select: none; z-index: 10; pointer-events: none; }
        .pagination > * { pointer-events: auto; }
        .nav-btn { opacity: 0.3; padding: 10px; border: none; background: none; color: inherit; font-size: inherit; }
        .nav-btn:hover { opacity: 1; }
        .nav-btn:disabled { opacity: 0.05; }
        .page-indicator { cursor: none; padding: 5px 10px; transition: 0.3s; opacity: 0.6; }
        .page-indicator:hover { opacity: 1; transform: scale(1.1); }

        /* --- 改進的發光進度條 --- */
        #progress-container {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 70%; max-width: 320px; height: 50px;
            z-index: 500; 
            display: flex; align-items: center; justify-content: center;
            opacity: 0; visibility: hidden; pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s;
            background: rgba(var(--bg-rgb), 0.1);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            padding: 0 20px;
        }
        #progress-container.active { opacity: 1; visibility: visible; pointer-events: auto; }

        .custom-range {
            -webkit-appearance: none; width: 100%; height: 4px; 
            background: linear-gradient(to right, rgba(128,128,128,0.1), rgba(128,128,128,0.5), rgba(128,128,128,0.1));
            border-radius: 2px;
            outline: none; cursor: none;
        }
        .custom-range::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; border-radius: 50%;
            background: var(--accent-color); 
            cursor: none;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 10px var(--accent-color), 0 0 20px rgba(128,128,128,0.5);
            border: 2px solid var(--bg-color);
        }
        .custom-range::-webkit-slider-thumb:active { transform: scale(1.3); }
        
        .progress-float-val {
            position: absolute; top: -40px; 
            font-size: 1.4rem; font-weight: 700; color: var(--accent-color);
            opacity: 0; transition: 0.2s;
            transform: translateY(10px);
            text-shadow: 0 0 10px rgba(128,128,128,0.3);
        }
        #progress-container.active .progress-float-val { opacity: 1; transform: translateY(0); }


        /* --- 側邊欄與目錄 --- */
        #toc-sidebar {
            width: var(--toc-width); height: 100%; background-color: var(--bg-color);
            border-left: 1px solid var(--placeholder-bg);
            position: fixed; right: 0; top: 0;
            transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 90; display: flex; flex-direction: column;
            padding: 80px 30px 30px; overflow-y: auto;
        }
        #toc-sidebar.open { transform: translateX(0); }
        .toc-list { list-style: none; padding: 0; margin: 0; }
        .toc-item { 
            margin-bottom: 18px; opacity: 0.6; transition: 0.2s; 
            font-size: 0.95rem; line-height: 1.4; display: block;
        }
        .toc-item:hover { opacity: 1; transform: translateX(-5px); color: var(--accent-color); }
        .toc-item[data-level="2"] { padding-left: 20px; font-size: 0.85rem; opacity: 0.5; }
        
        #mobile-toc-trigger {
            position: fixed; bottom: 25%; right: 0;
            width: 50px; height: 80px;
            background: rgba(128, 128, 128, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 40px 0 0 40px;
            z-index: 500;
            display: none; align-items: center; justify-content: center;
            border: 1px solid rgba(128,128,128,0.2); border-right: none;
            transition: width 0.3s;
        }
        #mobile-toc-trigger::after { content: "≡"; font-size: 24px; color: var(--text-color); opacity: 0.7; transform: translateX(5px); }
        
        #mobile-wheel-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(var(--bg-rgb), 0.1);
            z-index: 600;
            visibility: hidden; transition: backdrop-filter 0.4s, visibility 0.4s;
            overflow: hidden; touch-action: none;
        }
        #mobile-wheel-overlay.active { visibility: visible; backdrop-filter: blur(15px); }
        #wheel-container {
            position: absolute; top: 50%; right: -250px; width: 500px; height: 500px;
            transform: translateY(-50%); pointer-events: none;
        }
        .wheel-item {
            position: absolute; top: 50%; left: 50%; width: 300px; height: 40px;
            margin-top: -20px; margin-left: -150px;
            text-align: left; padding-left: 40px;
            transform-origin: center center; white-space: nowrap;
            font-size: 1.1rem; color: var(--text-color); opacity: 0; transition: color 0.2s;
            display: flex; align-items: center;
        }
        .wheel-item.active { color: var(--accent-color); font-weight: bold; }
        .wheel-item[data-level="2"] { font-size: 0.9rem; }
        .wheel-item span { display: block; }

        /* --- 純文本發光返回提示 --- */
        .toast-msg {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: none; padding: 0; border-radius: 0;
            color: var(--text-color);
            font-size: 1.4rem; font-weight: 600; letter-spacing: 2px;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            z-index: 200;
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--bg-color);
            text-align: center;
        }
        .toast-msg.show { opacity: 1; }
        
        #exit-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-color); display: flex; align-items: center; justify-content: center;
            z-index: 999; opacity: 0; visibility: hidden; transition: 0.5s;
        }
        #exit-overlay.active { opacity: 1; visibility: visible; }
        #exit-overlay span { font-size: 1.5rem; letter-spacing: 5px; animation: glow 1.5s infinite alternate; }
        @keyframes glow { from { text-shadow: 0 0 5px var(--text-color); opacity: 0.5; } to { text-shadow: 0 0 20px var(--text-color); opacity: 1; } }

        @media (min-width: 1025px) {
            body.has-toc-open .main-content { margin-right: var(--toc-width); }
            #mobile-toc-trigger { display: none !important; }
        }

        @media (max-width: 1024px) { 
            #custom-cursor { display: none !important; } 
            .reader-viewport { 
                margin: 60px auto 100px; width: 90%; 
                height: calc(100vh - 160px); 
            } 
            .page-slide { padding: 0 5px; gap: 20px; }
            .pagination { bottom: 20px; }
            .top-controls { top: 20px; left: 20px; }
            .desktop-toc-trigger { display: none; }
            #mobile-toc-trigger { display: flex; }
            #toc-sidebar { display: none; }
        }
    </style>
</head>
<body class="js-loading">
    <div id="custom-cursor"></div>
    
    <div id="exit-overlay"><span id="exit-text">正在返回...</span></div>
    <div class="toast-msg" id="swipe-hint">Release to Return</div>

    <div id="lightbox" onclick="closeLightbox()">
        <img id="lightbox-img" src="" alt="preview">
    </div>

    <!-- 進度條 -->
    <div id="progress-container">
        <div class="progress-float-val" id="slider-val">1</div>
        <input type="range" min="1" max="1" value="1" class="custom-range interactable" id="page-slider">
    </div>

    <div id="mobile-toc-trigger" class="interactable"></div>
    <div id="mobile-wheel-overlay">
        <div id="wheel-container"></div>
    </div>

    <div id="app-container">
        <main class="main-content">
            <div class="top-controls">
                <button class="icon-btn interactable" onclick="goBack()" aria-label="返回">
                    <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                </button>
            </div>
            
            <div class="desktop-toc-trigger">
                <button class="icon-btn interactable" id="desktop-toc-btn" onclick="toggleDesktopTOC()" aria-label="目錄">
                    <svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
                </button>
            </div>

            <div class="reader-viewport" id="viewport" aria-live="polite">
                <div class="loading-placeholder pulsing"></div>
            </div>

            <nav class="pagination" role="navigation">
                <button class="nav-btn interactable" id="prev-btn">PREV</button>
                <div class="page-indicator interactable" id="page-num">1 / 1</div>
                <button class="nav-btn interactable" id="next-btn">NEXT</button>
            </nav>
        </main>

        <aside id="toc-sidebar">
            <div style="font-size:1.2rem; margin-bottom:20px; opacity:0.5; font-weight:500;">目錄</div>
            <ul class="toc-list" id="desktop-toc-list"></ul>
        </aside>
    </div>

    <script>
        const viewport = document.getElementById('viewport');
        const pageNum = document.getElementById('page-num');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const cursor = document.getElementById('custom-cursor');
        
        const progressContainer = document.getElementById('progress-container');
        const pageSlider = document.getElementById('page-slider');
        const sliderVal = document.getElementById('slider-val');

        const desktopTocSidebar = document.getElementById('toc-sidebar');
        const desktopTocList = document.getElementById('desktop-toc-list');
        const desktopTocBtn = document.getElementById('desktop-toc-btn');
        const mobileTocTrigger = document.getElementById('mobile-toc-trigger');
        const mobileOverlay = document.getElementById('mobile-wheel-overlay');
        const wheelContainer = document.getElementById('wheel-container');

        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightbox-img');
        const swipeHint = document.getElementById('swipe-hint');
        const exitOverlay = document.getElementById('exit-overlay');

        let currentPage = 0, totalPages = 0, pages = [];
        let tocData = []; 
        let articleData = null;
        let currentArticleId = null; 
        let touchStartX = 0, touchMoveX = 0, isSwiping = false;
        let lastPageSwipeCount = 0; 
        let swipeResetTimer;

        let isWheelOpen = false, wheelItems = [], wheelAngle = 0, wheelVelocity = 0, wheelDragging = false, wheelLastY = 0, wheelRafId = null;
        const WHEEL_RADIUS = 300, ITEM_ANGLE_GAP = 12;

        // --- 1. Fetch & Layout (Async Image Loading) ---
        async function fetchArticleContent(id) {
            if (!id) throw new Error("ID missing");
            currentArticleId = id; 
            const response = await fetch(`./article/${id}.json`);
            if (!response.ok) throw new Error("Fetch failed");
            return await response.json();
        }

        // 預加載圖片並獲取原始尺寸的輔助函數
        function getImageMeta(src) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight, ok: true });
                img.onerror = () => resolve({ w: 800, h: 600, ok: false }); // Fallback
                img.src = src;
            });
        }

        async function layoutArticle(content) {
            articleData = content;
            document.title = content.title;
            viewport.innerHTML = `<div class="loading-placeholder pulsing" style="margin: auto;"></div>`;
            pages = []; currentPage = 0; tocData = [];

            const vH = viewport.clientHeight;
            const vW = viewport.clientWidth;
            if (vH <= 0) return;

            // 標題頁
            const titlePage = createPageDiv(0, true);
            titlePage.innerHTML = `<h1>${content.title}</h1><div class="meta" style="margin-top:10px; opacity:0.6;">${content.date}</div>`;
            titlePage.dataset.startIndex = 0; 
            pages.push(titlePage);

            let contentPageIndex = 1;
            let currentDiv = createPageDiv(1);
            let contentElementIndex = 0; 
            pages.push(currentDiv);

            // 隱藏的測量容器
            const tempDiv = document.createElement('div');
            const style = getComputedStyle(currentDiv);
            const pGap = parseFloat(style.gap) || 25;
            const paddingHorizontal = (parseFloat(style.paddingLeft) || 0) + (parseFloat(style.paddingRight) || 0);
            const availableWidth = vW - paddingHorizontal;
            
            tempDiv.style.cssText = `visibility:hidden; position:absolute; width:${availableWidth}px; left:0; top:0; z-index:-1;`;
            document.body.appendChild(tempDiv);

            let currentH = 0;

            try {
                if (!currentDiv.dataset.startIndex) currentDiv.dataset.startIndex = 1;

                for (let i = 0; i < content.paragraphs.length; i++) {
                    const item = content.paragraphs[i];
                    contentElementIndex++; 

                    let el, isHeader = false;
                    let displayedHeight = 0;

                    if (typeof item === 'string') {
                        el = document.createElement('p');
                        el.className = 'interactable-text';
                        el.innerText = item;
                        el.onclick = () => copyText(el);
                        
                        // 測量文字高度
                        tempDiv.innerHTML = '';
                        tempDiv.appendChild(el.cloneNode(true));
                        displayedHeight = tempDiv.clientHeight;

                    } else if (item.type === 'image') {
                        // 等待圖片元數據，計算實際渲染高度以避免壓縮
                        const meta = await getImageMeta(item.src);
                        const aspectRatio = meta.h / meta.w;
                        
                        // 圖片在頁面中會自動填滿寬度（受 max-width: 100% 限制）
                        // 計算如果寬度填滿，高度會是多少
                        // 注意：如果圖片原始寬度小於 availableWidth，它可能不會填滿，但為了安全起見，我們假設它可能佔用這些空間
                        // 這裡使用簡單邏輯：假設寬度為 availableWidth 計算高度
                        displayedHeight = availableWidth * aspectRatio;
                        
                        // 如果圖片本身超級長（比如長圖），限制其計算高度不超過一頁，視覺上由 object-fit: contain 處理
                        if (displayedHeight > vH) displayedHeight = vH; 

                        el = document.createElement('figure');
                        const ph = document.createElement('div');
                        ph.className = 'loading-placeholder pulsing interactable';
                        ph.dataset.src = item.src;
                        ph.dataset.alt = item.alt || '';
                        // 標記圖片，讓 lazyLoadImages 稍後處理
                        el.appendChild(ph);
                        
                        let captionHeight = 0;
                        if (item.caption) {
                            const cap = document.createElement('figcaption');
                            cap.innerText = item.caption;
                            el.appendChild(cap);
                            // 簡單估算 caption 高度
                            captionHeight = 30; 
                        }
                        displayedHeight += captionHeight;

                    } else if (item.type === 'header') {
                        isHeader = true;
                        el = document.createElement(item.level === 1 ? 'h2' : 'h3');
                        el.className = 'article-heading interactable-text';
                        el.dataset.level = item.level;
                        el.innerText = item.text;
                        
                        tempDiv.innerHTML = '';
                        tempDiv.appendChild(el.cloneNode(true));
                        displayedHeight = tempDiv.clientHeight;
                    }

                    if (!el) continue;

                    // --- 關鍵邏輯：換頁判斷 ---
                    // 如果當前已有內容，且加入新元素後會超出高度 -> 換頁
                    if (currentH > 0 && (currentH + displayedHeight + pGap > vH)) {
                        contentPageIndex++;
                        currentDiv = createPageDiv(contentPageIndex);
                        currentDiv.dataset.startIndex = contentElementIndex;
                        pages.push(currentDiv);
                        currentH = 0;
                    }

                    if (isHeader) tocData.push({ text: item.text, level: item.level, pageIndex: contentPageIndex });
                    currentDiv.appendChild(el);
                    currentH += (displayedHeight + pGap);
                }
            } finally {
                document.body.removeChild(tempDiv);
            }

            viewport.innerHTML = '';
            pages.forEach(p => viewport.appendChild(p));
            totalPages = pages.length;
            pageSlider.max = totalPages;

            setupTOC();
            restoreProgress();
            bindCursorEvents();
            lazyLoadImages();
        }

        // --- Custom Cursor Logic (Redone) ---
        let cursorState = { x: -100, y: -100, scale: 1, rotation: 45, hollow: false };
        let mousePos = { x: -100, y: -100 };
        let isCursorVisible = false;

        function initCursor() {
            if (window.matchMedia("(hover: none) or (max-width: 1024px)").matches) return;

            // 使用 RAF 更新位置，比直接在 mousemove 設置 style 效能更好
            function loop() {
                // 簡單的平滑處理 (Lerp) - 如果想要完全無延遲可設為 1
                const ease = 0.2; 
                cursorState.x += (mousePos.x - cursorState.x) * ease;
                cursorState.y += (mousePos.y - cursorState.y) * ease;

                // 構建 transform 字符串
                // translate3d 啟用 GPU 加速
                // translate(-50%, -50%) 保持中心點對齊
                let transform = `translate3d(${cursorState.x}px, ${cursorState.y}px, 0) translate(-50%, -50%)`;
                
                // 狀態處理
                if (cursorState.hollow) {
                    transform += ` rotate(45deg) scale(1.8)`;
                } else if (cursorState.scale !== 1) { // clicking
                    transform += ` rotate(45deg) scale(${cursorState.scale})`;
                } else {
                    transform += ` rotate(45deg)`;
                }

                cursor.style.transform = transform;
                
                // 首次移動後顯示鼠標
                if (!isCursorVisible && (mousePos.x > 0 || mousePos.y > 0)) {
                    isCursorVisible = true;
                    cursor.classList.add('active');
                }

                requestAnimationFrame(loop);
            }
            loop();

            document.addEventListener('mousemove', e => { 
                mousePos.x = e.clientX; 
                mousePos.y = e.clientY; 
            });
            document.addEventListener('mousedown', () => { cursorState.scale = 0.6; cursor.classList.add('clicking'); });
            document.addEventListener('mouseup', () => { cursorState.scale = 1; cursor.classList.remove('clicking'); });
        }

        // 修改 Hover 事件綁定，不再依賴 CSS 的 hover，改為更新 cursorState 對象
        function bindCursorEvents() {
            if (window.matchMedia("(hover: none) or (max-width: 1024px)").matches) return;
            
            const onEnter = () => { cursorState.hollow = true; cursor.classList.add('hollow'); };
            const onLeave = () => { cursorState.hollow = false; cursor.classList.remove('hollow'); };

            setTimeout(() => {
                document.querySelectorAll('.interactable, .interactable-text').forEach(el => {
                    el.removeEventListener('mouseenter', onEnter);
                    el.removeEventListener('mouseleave', onLeave);
                    el.addEventListener('mouseenter', onEnter);
                    el.addEventListener('mouseleave', onLeave);
                });
            }, 100);
        }

        // --- Progress Persistence (Unchanged) ---
        function saveProgress() {
            if (!currentArticleId || !pages[currentPage]) return;
            const idx = pages[currentPage].dataset.startIndex || 0;
            localStorage.setItem(`article_progress_${currentArticleId}`, idx);
        }

        function restoreProgress() {
            if (!currentArticleId) { updatePage(false); return; }
            const savedIdx = localStorage.getItem(`article_progress_${currentArticleId}`);
            if (savedIdx !== null) {
                const targetIdx = parseInt(savedIdx);
                let bestPage = 0;
                for (let i = 0; i < pages.length; i++) {
                    const pStart = parseInt(pages[i].dataset.startIndex || 0);
                    if (pStart <= targetIdx) bestPage = i; else break;
                }
                currentPage = bestPage;
            }
            updatePage(false);
        }

        // --- Update Page (Unchanged) ---
        function createPageDiv(index, isTitle = false) { 
            const div = document.createElement('div'); 
            div.className = 'page-slide'; 
            if (isTitle) div.classList.add('title-slide'); 
            div.dataset.index = index; 
            return div; 
        }

        function changePage(dir) { 
            const newPage = currentPage + dir; 
            if (newPage >= 0 && newPage < totalPages) { 
                currentPage = newPage; 
                updatePage(false); 
            }
        }

        function updatePage(instant = false) { 
            if (instant) viewport.classList.add('no-anim');
            else viewport.classList.remove('no-anim');

            pages.forEach((page, index) => { 
                page.style.transform = ''; 
                page.classList.remove('active', 'prev-page'); 
                if (index === currentPage) page.classList.add('active');
                else if (index < currentPage) page.classList.add('prev-page');
            }); 
            
            pageNum.innerText = `${currentPage + 1} / ${totalPages}`; 
            prevBtn.disabled = (currentPage === 0); 
            nextBtn.disabled = (currentPage === totalPages - 1); 
            
            if(!instant) {
                saveProgress(); 
                lazyLoadImages();
            }
        }

        // --- Slider (Unchanged) ---
        pageNum.addEventListener('click', (e) => {
            e.stopPropagation();
            progressContainer.classList.add('active');
            pageSlider.value = currentPage + 1;
            sliderVal.innerText = currentPage + 1;
        });

        pageSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            sliderVal.innerText = val;
            const targetPage = val - 1;
            if (currentPage !== targetPage) {
                currentPage = targetPage;
                updatePage(true);
            }
        });

        pageSlider.addEventListener('change', () => {
            updatePage(false);
            progressContainer.classList.remove('active');
        });

        // --- Image & Copy (Unchanged Logic, Updated for new layout) ---
        function openLightbox(src) {
            lightboxImg.src = src;
            lightbox.classList.add('active');
            cursorState.hollow = false; // Reset cursor state
            cursor.classList.remove('hollow');
        }
        function closeLightbox() {
            lightbox.classList.remove('active');
            setTimeout(() => { lightboxImg.src = ''; }, 300);
        }

        function lazyLoadImages() {
            const range = [currentPage-1, currentPage, currentPage+1, currentPage+2];
            range.forEach(idx => {
                if (idx < 0 || idx >= totalPages) return;
                const page = pages[idx];
                page.querySelectorAll('.loading-placeholder[data-src]').forEach(ph => {
                    if (ph.dataset.loading === 'true') return;
                    ph.dataset.loading = 'true';
                    const img = document.createElement('img');
                    img.src = ph.dataset.src;
                    img.alt = ph.dataset.alt;
                    img.className = 'interactable';
                    img.onload = () => {
                        img.classList.add('loaded');
                        img.onclick = (e) => { e.stopPropagation(); openLightbox(img.src); };
                        ph.parentNode.replaceChild(img, ph);
                        bindCursorEvents();
                    };
                    img.onerror = () => { setTimeout(() => { ph.dataset.loading = 'false'; lazyLoadImages(); }, 2000); };
                });
            });
        }

        async function copyText(el) { try { await navigator.clipboard.writeText(el.innerText); } catch {} }

        // --- TOC (Unchanged) ---
        function setupTOC() {
            if (tocData.length === 0) {
                desktopTocBtn.parentElement.style.display = 'none';
                mobileTocTrigger.style.display = 'none';
                return;
            }
            desktopTocList.innerHTML = '';
            tocData.forEach(item => {
                const li = document.createElement('li');
                li.className = 'toc-item interactable';
                li.innerText = item.text;
                li.dataset.level = item.level;
                li.onclick = () => { 
                    currentPage = item.pageIndex; 
                    updatePage(); 
                    if (window.innerWidth <= 1024) toggleDesktopTOC(); 
                };
                desktopTocList.appendChild(li);
            });
            if (window.innerWidth > 1024) toggleDesktopTOC(true);
            initMobileWheel();
        }

        function toggleDesktopTOC(forceOpen = null) {
            const isOpen = forceOpen !== null ? forceOpen : !desktopTocSidebar.classList.contains('open');
            desktopTocSidebar.classList.toggle('open', isOpen);
            document.body.classList.toggle('has-toc-open', isOpen);
            if (isOpen && articleData && window.innerWidth > 1024) setTimeout(() => layoutArticle(articleData), 300);
        }

        function initMobileWheel() {
            wheelContainer.innerHTML = '';
            wheelItems = [];
            tocData.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'wheel-item';
                div.dataset.index = index;
                const span = document.createElement('span');
                span.innerText = item.text;
                if (item.level > 1) span.style.paddingLeft = "20px";
                div.appendChild(span);
                wheelContainer.appendChild(div);
                wheelItems.push(div);
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    snapToItem(index, () => {
                        setTimeout(() => { currentPage = item.pageIndex; updatePage(); closeMobileWheel(); }, 200);
                    });
                });
            });
            mobileTocTrigger.onclick = openMobileWheel;
            mobileOverlay.addEventListener('touchstart', onWheelTouchStart, {passive: false});
            mobileOverlay.addEventListener('touchmove', onWheelTouchMove, {passive: false});
            mobileOverlay.addEventListener('touchend', onWheelTouchEnd);
            mobileOverlay.addEventListener('click', (e) => { if (e.clientX < window.innerWidth * 0.4) closeMobileWheel(); });
        }

        function openMobileWheel() {
            isWheelOpen = true;
            mobileOverlay.classList.add('active');
            mobileTocTrigger.style.width = '0px'; 
            document.body.style.overflow = 'hidden';
            let targetIdx = 0;
            for(let i=0; i<tocData.length; i++) { if(tocData[i].pageIndex <= currentPage) targetIdx = i; }
            wheelAngle = targetIdx * ITEM_ANGLE_GAP;
            wheelVelocity = 0;
            requestAnimationFrame(updateWheelVisuals);
        }

        function closeMobileWheel() {
            isWheelOpen = false;
            mobileOverlay.classList.remove('active');
            mobileTocTrigger.style.width = ''; 
            document.body.style.overflow = '';
        }

        function onWheelTouchStart(e) { wheelDragging = true; wheelLastY = e.touches[0].clientY; wheelVelocity = 0; cancelAnimationFrame(wheelRafId); }
        function onWheelTouchMove(e) {
            if (!wheelDragging) return;
            e.preventDefault();
            const y = e.touches[0].clientY;
            wheelAngle += (wheelLastY - y) * 0.5; 
            wheelVelocity = (wheelLastY - y) * 0.5;
            wheelLastY = y;
            requestAnimationFrame(updateWheelVisuals);
        }
        function onWheelTouchEnd(e) { wheelDragging = false; inertiaLoop(); }

        function inertiaLoop() {
            if (wheelDragging || !isWheelOpen) return;
            wheelVelocity *= 0.95;
            wheelAngle += wheelVelocity;
            const maxAngle = (wheelItems.length - 1) * ITEM_ANGLE_GAP;
            if (wheelAngle < -10) { wheelAngle += (-10 - wheelAngle) * 0.1; wheelVelocity = 0; }
            else if (wheelAngle > maxAngle + 10) { wheelAngle += (maxAngle + 10 - wheelAngle) * 0.1; wheelVelocity = 0; }
            updateWheelVisuals();
            if (Math.abs(wheelVelocity) > 0.1) wheelRafId = requestAnimationFrame(inertiaLoop);
        }

        function snapToItem(index, callback) {
            const targetAngle = index * ITEM_ANGLE_GAP;
            const animate = () => {
                const diff = targetAngle - wheelAngle;
                if (Math.abs(diff) < 0.5) { wheelAngle = targetAngle; updateWheelVisuals(); if (callback) callback(); return; }
                wheelAngle += diff * 0.1;
                updateWheelVisuals();
                requestAnimationFrame(animate);
            };
            animate();
        }

        function updateWheelVisuals() {
            wheelItems.forEach((item, index) => {
                const itemAngle = (index * ITEM_ANGLE_GAP) - wheelAngle;
                if (itemAngle < -90 || itemAngle > 90) { item.style.visibility = 'hidden'; return; }
                item.style.visibility = 'visible';
                const rad = itemAngle * (Math.PI / 180);
                const y = Math.sin(rad) * WHEEL_RADIUS;
                const x = (Math.cos(rad) * WHEEL_RADIUS) - WHEEL_RADIUS;
                const rotate = itemAngle * 0.5;
                item.style.transform = `translate(${x}px, ${y}px) rotate(${rotate}deg)`;
                const dist = Math.abs(itemAngle);
                item.style.opacity = Math.max(0, 1 - (dist / 90));
                if (dist < ITEM_ANGLE_GAP / 2) item.classList.add('active'); else item.classList.remove('active');
            });
        }

        function goBack() {
            document.body.style.opacity = '0';
            setTimeout(() => { window.location.href = './articles.html'; }, 500);
        }

        async function initialize() {
            try {
                const params = new URLSearchParams(window.location.search);
                const articleId = params.get('id');
                const content = await fetchArticleContent(articleId);
                await document.fonts.ready;
                // 注意：這裡直接調用 layoutArticle，其內部現在會等待圖片元數據
                await layoutArticle(content);
                
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => { if (articleData && !isWheelOpen) layoutArticle(articleData); }, 250);
                });
                initInputs();
                initCursor(); // Initialize the new cursor logic
            } catch (error) { console.error("Init failed", error); } 
            finally { document.body.classList.remove('js-loading'); }
        }

        function initInputs() {
            prevBtn.addEventListener('click', () => changePage(-1)); 
            nextBtn.addEventListener('click', () => changePage(1)); 
            document.addEventListener('keydown', (e) => { 
                if (e.key === 'ArrowLeft') { prevBtn.click(); } 
                else if (e.key === 'ArrowRight') { nextBtn.click(); } 
            });

            if (window.matchMedia("(hover: none) or (max-width: 1024px)").matches) {
                viewport.addEventListener('touchstart', e => {
                    touchStartX = e.touches[0].clientX;
                    touchMoveX = touchStartX;
                    isSwiping = true;
                    viewport.classList.add('no-anim');
                }, {passive: true});

                viewport.addEventListener('touchmove', e => {
                    if (!isSwiping) return;
                    touchMoveX = e.touches[0].clientX;
                    const delta = touchMoveX - touchStartX;
                    const page = pages[currentPage];
                    if (!page) return;
                    
                    let tx = delta;
                    if ((currentPage === 0 && delta > 0) || (currentPage === totalPages-1 && delta < 0)) tx *= 0.4;
                    page.style.transform = `translateX(${tx}px)`;
                }, {passive: true});

                viewport.addEventListener('touchend', e => {
                    if (!isSwiping) return;
                    isSwiping = false;
                    viewport.classList.remove('no-anim');
                    const delta = touchMoveX - touchStartX;
                    pages[currentPage].style.transform = '';

                    if (delta < -50) { 
                        if (currentPage < totalPages - 1) { changePage(1); resetSwipeExit(); }
                        else handleSwipeExit(); 
                    } else if (delta > 50) { 
                        if (currentPage > 0) { changePage(-1); resetSwipeExit(); }
                        else handleSwipeExit();
                    } else {
                        updatePage(false);
                    }
                }, {passive: true});
            }
        }

        function handleSwipeExit() {
            clearTimeout(swipeResetTimer);
            lastPageSwipeCount++;
            if (lastPageSwipeCount === 1) {
                swipeHint.classList.add('show');
                updatePage(false);
                swipeResetTimer = setTimeout(resetSwipeExit, 3000);
            } else if (lastPageSwipeCount >= 2) {
                swipeHint.classList.remove('show');
                exitOverlay.classList.add('active');
                setTimeout(goBack, 1000);
            }
        }
        function resetSwipeExit() { lastPageSwipeCount = 0; swipeHint.classList.remove('show'); }

        window.addEventListener('load', initialize);
    </script>
</body>
</html>
