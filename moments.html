<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Moments</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@300;500;700&display=swap" rel="stylesheet">
    
    <script>
        const momentsData = [
            { id: "moment-1", type: "image", title: "風暴與花", content: { imageSrc: "https://images.unsplash.com/photo-1493663284031-b7e3aefcae8e?auto=format&fit=crop&w=1200&q=80", text: "風暴過後，我們在廢墟上種花。<br>生活不是等待，而是創造。" } },
            { id: "moment-gallery-1", type: "gallery", title: "城市碎片 (組圖)", content: { text: "光影的切片，記錄時間的流逝。", images: [ "https://images.unsplash.com/photo-1519681393784-d120267933ba?auto=format&fit=crop&w=1200&q=80", "https://images.unsplash.com/photo-1500462918059-b1a0cb512f1d?auto=format&fit=crop&w=1200&q=80", "https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?auto=format&fit=crop&w=1200&q=80" ] } },
            { id: "moment-2", type: "poem", title: "如霧起時", content: { lines: [ "如霧起時", "敲打著窗櫺的", "不是風", "是經年的沈默", "這是為了測試長詩", "而增加的文字", "當內容超過一屏", "你可以左右滑動", "在豎排的文字森林裡", "尋找下一個句子", "光從右邊來", "故事往左邊去", "這就是傳統的閱讀", "在數字時代的回響", "就像一本", "永遠翻不完的書" ], author: "Joyance" } },
            { id: "moment-3", type: "image", title: "久別重逢", content: { imageSrc: "https://images.unsplash.com/photo-1516483638261-f4dbaf036963?auto=format&fit=crop&w=1200&q=80", text: `"所有的相遇，都是久別重逢。"`, meta: "2023.12.07" } }
        ];
    </script>

    <style>
        :root {
            --bg-color: #ffffff; --text-color: #1a1a1a;
            --toc-bg-pc: rgba(255, 255, 255, 0.0);
            --ease-elastic: cubic-bezier(0.25, 1, 0.5, 1);
        }
        @media (prefers-color-scheme: dark) { 
            :root { --bg-color: #000000; --text-color: #e5e5e5; --toc-bg-pc: rgba(0,0,0,0); } 
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body, html { 
            cursor: none !important; user-select: none; -webkit-user-select: none; 
            width: 100%; height: 100%; overflow: hidden;
            background: var(--bg-color); color: var(--text-color); 
            font-family: 'Noto Serif TC', serif; 
        }

        /* 入場與離場動畫 */
        body { opacity: 0; animation: pageIn 1s var(--ease-elastic) forwards; transform-origin: center center; }
        body.exiting { animation: pageOut 0.8s var(--ease-elastic) forwards; }

        @keyframes pageIn { from { opacity: 0; transform: scale(1.05); } to { opacity: 1; transform: scale(1); } }
        @keyframes pageOut { to { opacity: 0; transform: scale(0.92); filter: blur(2px); } }

        /* --- Custom Cursor --- */
        #custom-cursor { position: fixed; top: 0; left: 0; width: 12px; height: 12px; background-color: var(--text-color); transform: rotate(45deg); pointer-events: none; z-index: 99999; transition: transform 0.15s, width 0.2s, height 0.2s; mix-blend-mode: difference; }
        #custom-cursor.hollow { background: transparent; border: 1.5px solid var(--text-color); transform: rotate(45deg) scale(1.5); }
        .interactable, .interactable-text, .gallery-item { cursor: none; }

        /* --- UI Controls --- */
        .back-arrow { position: fixed; top: 30px; left: 30px; z-index: 200; width: 40px; height: 40px; opacity: 0.6; transition: 0.3s; display: flex; align-items: center; justify-content: center; }
        .back-arrow:hover { opacity: 1; transform: scale(1.1); }
        .back-arrow svg { width: 24px; height: 24px; fill: var(--text-color); }

        /* --- Layout: Native Scroll Snap for Resistance --- */
        .snap-container { 
            height: 100vh; width: 100vw; 
            overflow-y: scroll; 
            scroll-snap-type: y mandatory; /* 核心：強制吸附，產生阻力感 */
            scroll-behavior: smooth;
        }
        .snap-container::-webkit-scrollbar { display: none; } 

        .moment-section { 
            height: 100vh; width: 100vw; 
            scroll-snap-align: start; 
            scroll-snap-stop: always; 
            position: relative; 
            display: flex; justify-content: center; align-items: center; 
            overflow: hidden; 
        }

        /* --- Image Type --- */
        .img-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 1s; z-index: 1; }
        .img-bg.loaded { opacity: 1; }
        .bg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, transparent, rgba(0,0,0,0.4)); z-index: 2; }
        .text-overlay { z-index: 3; position: relative; padding: 20px; max-width: 600px; text-align: center; color: #fff; transform: translateY(30px); opacity: 0; transition: 1s var(--ease-elastic); }
        .moment-section.active .text-overlay { transform: translateY(0); opacity: 1; }
        .moment-text { font-size: 1.15rem; line-height: 1.8; text-shadow: 0 4px 15px rgba(0,0,0,0.6); }

        /* --- Gallery Type --- */
        .gallery-mode { background: var(--bg-color); flex-direction: column; }
        .gallery-text { margin-bottom: 4vh; max-width: 500px; text-align: center; z-index: 4; }
        .gallery-scroll { 
            display: flex; gap: 40px; width: 100%; padding: 0 10vw; 
            overflow-x: auto; scroll-snap-type: x mandatory; 
            align-items: center; height: 60vh; z-index: 10; 
            scrollbar-width: none; 
        }
        .gallery-scroll::-webkit-scrollbar { display: none; }
        .gallery-item { 
            flex: 0 0 auto; height: 100%; width: auto; 
            scroll-snap-align: center; 
            transition: transform 0.3s; 
        }
        .gallery-item img { height: 100%; width: auto; max-width: 80vw; object-fit: cover; display: block; }
        .gallery-item:hover { transform: scale(1.01); }

        /* --- Poem Type (Long Content Scrollable) --- */
        .poem-mode { background: var(--bg-color); overflow-x: auto; scrollbar-width: none; } /* 關鍵：允許整個區塊水平滾動 */
        .poem-mode::-webkit-scrollbar { display: none; }
        .poem-wrapper {
            /* 讓wrapper比視窗寬，以容納所有豎列詩句 */
            display: flex; 
            justify-content: flex-end; /* 讓內容靠右對齊 (豎排文字的起點) */
            align-items: center;     /* 垂直居中 */
            min-width: 100vw; /* 至少一屏寬 */
            width: max-content; /* 關鍵：讓容器根據內容自動增寬 */
            height: 100%;
            padding: 0 50vw; /* 確保內容在螢幕中央開始 */
        }
        .poem-content {
            display: flex;
            writing-mode: vertical-rl; 
            text-orientation: upright;
            gap: 3rem; 
            max-height: 80vh;
            padding-right: 50vw; /* 讓詩歌從中央偏右開始 */
            transform: translateX(50%); /* 修正視覺定位，將詩歌的右邊緣對齊中心 */
        }
        .poem-line { 
            font-size: 1.4rem; letter-spacing: 0.3em; line-height: 1.5; 
            white-space: nowrap; 
        }
        .poem-author { font-size: 0.9rem; margin-top: 30px; opacity: 0.6; writing-mode: vertical-rl; }

        /* --- PC TOC (Slim) --- */
        .pc-toc-panel { 
            display: none; position: fixed; top: 0; right: 0; bottom: 0; width: 60px; 
            background: var(--toc-bg-pc); z-index: 150; 
            flex-direction: column; justify-content: center; align-items: center; gap: 15px; 
        }
        .pc-toc-item { 
            writing-mode: vertical-rl; text-orientation: upright; font-size: 0.8rem; 
            color: var(--text-color); opacity: 0.2; transition: 0.3s; cursor: none; padding: 10px 0;
            position: relative;
        }
        .pc-toc-item:hover, .pc-toc-item.active { opacity: 1; font-weight: bold; }
        .pc-toc-item.active::after { content: ''; position: absolute; right: -8px; top: 50%; transform: translateY(-50%); width: 4px; height: 4px; background: var(--text-color); border-radius: 50%; }

        /* --- Mobile Wheel (Interactive) --- */
        .mobile-wheel { 
            display: none; position: fixed; bottom: -120px; left: 50%; transform: translateX(-50%); 
            width: 240px; height: 240px; border-radius: 50%; z-index: 150; 
            touch-action: none; 
            background: rgba(125,125,125,0.05); 
        }
        .wheel-container { width: 100%; height: 100%; position: relative; transition: transform 0.4s var(--ease-elastic); will-change: transform; } /* 關鍵：增加過渡效果用於卡位 */
        .wheel-item { position: absolute; top: 50%; left: 50%; transform-origin: 0 0; writing-mode: vertical-rl; text-orientation: upright; font-size: 0.75rem; opacity: 0.5; pointer-events: none; }
        .wheel-indicator { display: none; position: fixed; bottom: 115px; left: 50%; transform: translateX(-50%); width: 2px; height: 12px; background: var(--text-color); z-index: 151; }

        /* --- End Hint & Toast --- */
        .end-hint { 
            position: fixed; bottom: 40px; width: 100%; text-align: center; 
            font-size: 0.85rem; letter-spacing: 2px; opacity: 0; 
            transform: translateY(20px); transition: 0.4s var(--ease-elastic); 
            pointer-events: none; z-index: 300; 
        }
        .end-hint.visible { opacity: 1; transform: translateY(0); }
        .toast-msg { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 0.8rem; opacity: 0; pointer-events: none; transition: 0.3s; z-index: 300; }

        /* Lightbox */
        .lightbox { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color); z-index: 999; opacity: 0; pointer-events: none; transition: 0.4s; display: flex; justify-content: center; align-items: center; }
        .lightbox.active { opacity: 1; pointer-events: auto; }
        .lightbox img { max-width: 90%; max-height: 90%; object-fit: contain; transform: scale(0.9); transition: 0.4s; }
        .lightbox.active img { transform: scale(1); }

        /* --- Responsive --- */
        @media (min-width: 769px) {
            .pc-toc-panel { display: flex; }
            .mobile-wheel, .wheel-indicator { display: none !important; }
        }
        @media (max-width: 768px) {
            body, html { cursor: auto !important; }
            #custom-cursor { display: none; }
            .mobile-wheel, .wheel-indicator { display: block; }
            .gallery-item { width: 75vw; }
            .poem-content { gap: 1.5rem; max-height: 70vh; }
            .poem-line { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <div id="custom-cursor"></div>
    <div class="back-arrow interactable" onclick="triggerHomeExit()">
        <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
    </div>

    <div class="pc-toc-panel" id="pc-toc-list"></div>

    <div class="mobile-wheel" id="mobile-wheel"><div class="wheel-container" id="wheel-container"></div></div>
    <div class="wheel-indicator"></div>

    <div class="toast-msg" id="toast-msg">Copied</div>
    <div class="end-hint" id="end-hint">鬆開手指以返回首頁</div>

    <div class="snap-container" id="main-scroll"></div>

    <div class="lightbox" id="lightbox" onclick="closeLightbox()"><img id="lb-img" src=""></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // momentsData 數據已在 <script> 頂部定義
        if (typeof momentsData === 'undefined' || momentsData.length === 0) return;

        const scrollContainer = document.getElementById('main-scroll');
        const pcTocList = document.getElementById('pc-toc-list');
        const wheelContainer = document.getElementById('wheel-container');
        const totalSlides = momentsData.length;
        const isPC = window.innerWidth > 768;

        // --- 1. Content Builder ---
        momentsData.forEach((moment, index) => {
            const section = document.createElement('section');
            section.className = 'moment-section';
            section.id = `sec-${index}`;

            let inner = '';
            if (moment.type === 'image') {
                inner = `
                    <img data-src="${moment.content.imageSrc}" class="img-bg lazy-img">
                    <div class="bg-overlay"></div>
                    <div class="text-overlay">
                        <p class="moment-text interactable-text" onclick="copyText(this)">${moment.content.text}</p>
                    </div>`;
            } else if (moment.type === 'gallery') {
                section.classList.add('gallery-mode');
                const imgs = moment.content.images.map((src, i) => 
                    `<div class="gallery-item interactable" onclick="event.stopPropagation(); openLightbox('${moment.id}', ${i})">
                        <img data-src="${src}" class="lazy-img">
                     </div>`
                ).join('');
                inner = `<div class="gallery-text">${moment.content.text}</div>
                         <div class="gallery-scroll" id="gal-scroll-${index}">${imgs}</div>`;
            } else if (moment.type === 'poem') {
                section.classList.add('poem-mode');
                // 詩歌結構：Section(允許X軸滾動) -> Wrapper(居中，寬度max-content) -> Content(豎排)
                const lines = moment.content.lines.map(line => `<div class="poem-line">${line}</div>`).join('');
                inner = `
                    <div class="poem-wrapper interactable-text" onclick="copyText(this)">
                        <div class="poem-content">
                            ${lines}
                            <div class="poem-author">—— ${moment.content.author}</div>
                        </div>
                    </div>`;
            }
            section.innerHTML = inner;
            scrollContainer.appendChild(section);

            // TOC
            const toc = document.createElement('div');
            toc.className = 'pc-toc-item interactable';
            toc.innerText = moment.title;
            toc.onclick = () => section.scrollIntoView({ behavior: 'smooth' });
            pcTocList.appendChild(toc);
        });

        // --- 2. PC Gallery Scroll Logic (Fixing the "Stuck" Issue) ---
        if (isPC) {
            document.querySelectorAll('.gallery-scroll').forEach(gal => {
                gal.addEventListener('wheel', (e) => {
                    // 關鍵修正：檢查是否有水平滾動的空間，才攔截事件
                    if (gal.scrollWidth > gal.clientWidth) {
                        e.preventDefault();
                        // 修正：增加阻力感，使用更小的增量
                        gal.scrollLeft += e.deltaY * 0.8;
                    }
                    // 如果沒有水平空間，則讓垂直滾動事件冒泡，繼續滾動頁面
                }, { passive: false });
            });
        }

        // --- 3. Wheel & Scroll Sync ---
        const updateActiveState = () => {
            const scrollY = scrollContainer.scrollTop;
            const h = window.innerHeight;
            const idx = Math.round(scrollY / h);
            
            document.querySelectorAll('.moment-section').forEach((s, i) => {
                if(i === idx) s.classList.add('active');
                else s.classList.remove('active');
            });
            document.querySelectorAll('.pc-toc-item').forEach((t, i) => t.classList.toggle('active', i === idx));
            
            // Sync Mobile Wheel display (角度自動對齊當前頁面)
            const anglePerSlide = 360 / totalSlides;
            const deg = -idx * anglePerSlide; 
            wheelContainer.style.transform = `rotate(${deg}deg)`;
        };
        scrollContainer.addEventListener('scroll', updateActiveState);
        setTimeout(updateActiveState, 100);

        // --- 4. Mobile Wheel Interaction (Limited & Snap) ---
        const wheelObj = document.getElementById('mobile-wheel');
        let wStartAngle, wCurrentRot = 0;
        const anglePerSlide = 360 / totalSlides;
        
        // 輔助函數：獲取當前 CSS 角度
        const getContainerRotation = () => {
            const style = window.getComputedStyle(wheelContainer);
            const matrix = new DOMMatrix(style.transform);
            return Math.atan2(matrix.b, matrix.a) * (180/Math.PI);
        };

        wheelObj.addEventListener('touchstart', (e) => {
            e.stopPropagation(); 
            const rect = wheelObj.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            wStartAngle = Math.atan2(e.touches[0].clientY - cy, e.touches[0].clientX - cx) * 180 / Math.PI;
            wCurrentRot = getContainerRotation();
        }, { passive: false });

        wheelObj.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            const rect = wheelObj.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            const curAngle = Math.atan2(e.touches[0].clientY - cy, e.touches[0].clientX - cx) * 180 / Math.PI;
            
            const diff = curAngle - wStartAngle;
            let newRotation = wCurrentRot + diff;

            // 限制：只能順時針轉動 (角度必須介於 0 到 -360度之間)
            // 將角度轉換為正數 (0到360) 進行比較
            let normalizedNewRotation = newRotation % 360;
            if (normalizedNewRotation > 0) normalizedNewRotation -= 360; 

            // 轉到底的限制 (最後一頁為 -360 * (N-1)/N)
            const maxNegativeAngle = -(totalSlides - 1) * anglePerSlide;
            
            // 如果用戶嘗試向後轉動 (角度變大/接近0)，則鎖定在 0 (第一頁)
            if (newRotation > 0) newRotation = 0;

            // 如果用戶嘗試轉過頭 (角度比最後一頁還小)，則鎖定在最大角度
            if (newRotation < -360) newRotation = -360; // 限制最多只能轉一圈

            wheelContainer.style.transform = `rotate(${newRotation}deg)`;
        }, { passive: false });

        wheelObj.addEventListener('touchend', (e) => {
            const currentAngle = getContainerRotation();
            
            // 關鍵修正：自動卡位 (Snap)
            // 找出最接近的索引
            let closestIndex = Math.round((-currentAngle) / anglePerSlide);
            
            // 確保索引在有效範圍內
            if (closestIndex < 0) closestIndex = 0;
            if (closestIndex >= totalSlides) closestIndex = totalSlides - 1; // 轉到底，卡在最後一頁

            // 計算精確的卡位角度
            const snapAngle = -closestIndex * anglePerSlide;

            // 平滑過渡到卡位角度
            wheelContainer.style.transform = `rotate(${snapAngle}deg)`;
            
            // 跳轉到對應的頁面
            document.getElementById(`sec-${closestIndex}`).scrollIntoView({ behavior: 'smooth' });
        });
        
        // Wheel Item Generation
        const radius = 120;
        momentsData.forEach((m, i) => {
            const rad = (i / totalSlides) * 2 * Math.PI - Math.PI / 2;
            const x = radius * Math.cos(rad);
            const y = radius * Math.sin(rad);
            const el = document.createElement('div');
            el.className = 'wheel-item';
            el.innerText = m.title;
            el.style.transform = `translate(${x}px, ${y}px) rotate(${rad * 180 / Math.PI + 90}deg)`;
            wheelContainer.appendChild(el);
        });

        // --- 5. "Pull to Home" Logic (End of Page) ---
        let tStartY = 0;
        let isPulling = false;
        const hint = document.getElementById('end-hint');

        scrollContainer.addEventListener('touchstart', e => { tStartY = e.touches[0].clientY; isPulling = false; }, {passive: true});
        
        scrollContainer.addEventListener('touchmove', e => {
            const currentY = e.touches[0].clientY;
            const delta = tStartY - currentY;
            const isBottom = scrollContainer.scrollHeight - scrollContainer.scrollTop <= scrollContainer.clientHeight + 5;
            
            if (isBottom && delta > 20) {
                isPulling = true;
                hint.classList.add('visible');
                hint.innerText = delta > 100 ? "鬆開手指確認返回" : "繼續上滑以返回首頁";
                scrollContainer.style.transform = `translateY(${-Math.min(delta/4, 50)}px)`;
            }
        }, {passive: true});

        scrollContainer.addEventListener('touchend', e => {
            scrollContainer.style.transform = ''; 
            const delta = tStartY - e.changedTouches[0].clientY;
            
            if (isPulling && delta > 100) {
                triggerHomeExit();
            } else {
                hint.classList.remove('visible');
            }
            isPulling = false;
        });

        // --- 6. Lazy Load & Cursor ---
        const observer = new IntersectionObserver(entries => {
            entries.forEach(e => {
                if(e.isIntersecting) {
                    e.target.src = e.target.dataset.src;
                    e.target.onload = () => e.target.classList.add('loaded');
                    observer.unobserve(e.target);
                }
            });
        }, {rootMargin: "50px"});
        document.querySelectorAll('.lazy-img').forEach(img => observer.observe(img));

        bindCursor();
    });

    // --- Global Helpers ---
    function triggerHomeExit() {
        document.getElementById('end-hint').innerText = "正在返回...";
        document.body.classList.add('exiting');
        // 假設跳轉到 home.html
        setTimeout(() => window.location.href = 'home.html', 800); 
    }

    async function copyText(el) { 
        try { await navigator.clipboard.writeText(el.innerText); 
        const t = document.getElementById('toast-msg'); t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 1000); } catch(e){} 
    }

    window.openLightbox = (mid, idx) => {
        const m = momentsData.find(x => x.id === mid);
        document.getElementById('lb-img').src = m.content.images[idx];
        document.getElementById('lightbox').classList.add('active');
    };
    window.closeLightbox = () => document.getElementById('lightbox').classList.remove('active');

    const cursor = document.getElementById('custom-cursor');
    document.addEventListener('mousemove', e => { cursor.style.left = e.clientX+'px'; cursor.style.top = e.clientY+'px'; });
    function bindCursor() {
        document.querySelectorAll('.interactable, .interactable-text, .gallery-item').forEach(el => {
            el.addEventListener('mouseenter', () => cursor.classList.add('hollow'));
            el.addEventListener('mouseleave', () => cursor.classList.remove('hollow'));
        });
    }
    </script>
</body>
</html>
